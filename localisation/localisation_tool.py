#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
╔═══════════════════════════════════════════════════════════════╗
║  HOI4 Localization Tool - Russian/Ukrainian to English        ║
║                                                               ║
║  Created by: iAmScienceMan                                    ║
║  Originally made for: East-Showdown                           ║
║  License: EPL 2.0 (Eclipse Public License 2.0)                ║
║                                                               ║
║  Femboys rule the world                                       ║
╚═══════════════════════════════════════════════════════════════╝

Інструмент для локалізації модів HOI4.
Порівнює російську та англійську локалізацію, знаходить відсутні переклади
та генерує файли для перекладачів.
"""

__author__ = "iAmScienceMan"
__project__ = "East-Showdown"
__version__ = "1.0.0"
__license__ = "EPL-2.0"
__credits__ = "iAmScienceMan"
__motto__ = "Femboys rule the world"

import os
import sys
import re
import shutil
from pathlib import Path
from datetime import datetime

# CRITICAL FIX FOR WINDOWS: Change to script's directory
# This fixes the issue where Windows runs scripts from System32
script_dir = os.path.dirname(os.path.abspath(__file__))
try:
    os.chdir(script_dir)
except Exception as e:
    print(f"CRITICAL ERROR: Cannot change to script directory: {e}")
    print("Make sure to run this script from the localisation/ folder.")
    input("Press Enter to exit...")
    sys.exit(1)

# Константи директорій
RUSSIAN_DIR = "./russian"
ENGLISH_DIR = "./english"
TEMP_DIR = "./temp"
WIP_DIR = "./wip"
REPORT_FILE = "localization_report.txt"

# ANSI color codes
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

def _get_credits_line():
    """Генерує рядок кредитів для звітів / Генерирует строку кредитов для отчетов"""
    return f"Generated by {__author__}'s tool | {__project__} | {__motto__}"

def _show_credits_banner():
    """Показує банер з кредитами / Показывает баннер с кредитами"""
    print("=" * 65)
    print(f"  HOI4 Localization Tool v{__version__}")
    print(f"  Created by: {Colors.GREEN}{__author__}{Colors.NC}")
    print(f"  Originally made for: {Colors.BLUE}{__project__}{Colors.NC}")
    print(f"  License: {__license__}")
    print()
    print(f"  {Colors.YELLOW}{__motto__}{Colors.NC}")
    print("=" * 65)
    print()

# Russian UI text
UI_RU = {
    'check_header': 'Проверка полноты локализации',
    'create_header': 'Создание файлов для перевода',
    'error_russian_dir': f'Ошибка: русская директория не найдена по пути {RUSSIAN_DIR}',
    'error_english_dir': f'Ошибка: английская директория не найдена по пути {ENGLISH_DIR}',
    'error_missing_keys': f'Ошибка: сначала запустите скрипт проверки локализации!',
    'error_no_temp_file': 'не найден',
    'step1_merge': '[1] Объединение всех ключей из каждой локали в отдельные файлы...',
    'processing_russian': 'Обработка русских файлов...',
    'processing_english': 'Обработка английских файлов...',
    'processed_russian': '✓ Обработано русских файлов:',
    'processed_english': '✓ Обработано английских файлов:',
    'step2_compare': '[2] Сравнение ключей между локалями...',
    'unique_russian': 'Уникальных русских ключей:',
    'unique_english': 'Уникальных английских ключей:',
    'all_keys_present': '✓ Все русские ключи присутствуют в английской локализации!',
    'localization_complete': 'Локализация завершена на 100%!',
    'missing_keys_found': '✗ Найдены отсутствующие ключи в англ ийской локализации:',
    'completion': 'Завершенность английской локализации:',
    'step3_search': '[3] Поиск отсутствующих ключей по файлам и создание отчета...',
    'summary': 'Итоги',
    'localization_completion': 'Завершенность локализации:',
    'missing_keys': 'Отсутствующих ключей:',
    'report_saved': 'Детальный отчет сохранен в:',
    'temp_saved': 'Временные файлы сохранены в:',
    'file': 'Файл:',
    'missing_in_file': 'Отсутствующих ключей:',
    'path_original': 'Путь к оригиналу:',
    'path_translation': 'Путь к переводу:',
    'creating_wip': 'Создание файлов с отсутствующими ключами...',
    'created': 'Создан:',
    'files_created': 'Создано файлов:',
    'total_keys': 'Всего ключей для перевода:',
    'files_location': 'Файлы находятся в директории:',
    'instructions': 'Инструкция:',
    'instruction1': f'1. Откройте файлы в {WIP_DIR}',
    'instruction2': '2. Переведите русские значения на английский',
    'instruction3': '3. Скопируйте содержимое в соответствующие файлы в ./english/',
    'cleaning_wip': f'Очистка существующей директории {WIP_DIR}...',
}

# Ukrainian UI text
UI_UA = {
    'check_header': 'Перевірка повноти локалізації',
    'create_header': 'Створення файлів для перекладу',
    'error_russian_dir': f'Помилка: Російська директорія не знайдена за адресою {RUSSIAN_DIR}',
    'error_english_dir': f'Помилка: Англійська директорія не знайдена за адресою {ENGLISH_DIR}',
    'error_missing_keys': f'Помилка: Спочатку запустіть скрипт перевірки локалізації!',
    'error_no_temp_file': 'не знайдено',
    'step1_merge': "[1] Об'єднання всіх ключів з кожної локалі в окремі файли...",
    'processing_russian': 'Обробка російських файлів...',
    'processing_english': 'Обробка англійських файлів...',
    'processed_russian': '✓ Оброблено російських файлів:',
    'processed_english': '✓ Оброблено англійських файлів:',
    'step2_compare': '[2] Порівняння ключів між локалями...',
    'unique_russian': 'Унікальних російських ключів:',
    'unique_english': 'Унікальних англійських ключів:',
    'all_keys_present': '✓ Всі російські ключі присутні в англійській локалізації!',
    'localization_complete': 'Локалізація завершена на 100%!',
    'missing_keys_found': '✗ Знайдено відсутніх ключів в англійській локалізації:',
    'completion': 'Завершеність англійської локалізації:',
    'step3_search': '[3] Пошук відсутніх ключів у файлах та створення звіту...',
    'summary': 'Підсумок',
    'localization_completion': 'Завершеність локалізації:',
    'missing_keys': 'Відсутніх ключів:',
    'report_saved': 'Детальний звіт збережено в:',
    'temp_saved': 'Тимчасові файли збережено в:',
    'file': 'Файл:',
    'missing_in_file': 'Відсутніх ключів:',
    'path_original': 'Шлях до оригіналу:',
    'path_translation': 'Шлях до перекладу:',
    'creating_wip': 'Створення файлів з відсутніми ключами...',
    'created': 'Створено:',
    'files_created': 'Створено файлів:',
    'total_keys': 'Всього ключів для перекладу:',
    'files_location': 'Файли знаходяться в директорії:',
    'instructions': 'Інструкція:',
    'instruction1': f'1. Відкрийте файли в {WIP_DIR}',
    'instruction2': '2. Перекладіть російські значення на англійську',
    'instruction3': '3. Скопіюйте вміст у відповідні файли в ./english/',
    'cleaning_wip': f'Очищення існуючої директорії {WIP_DIR}...',
}


def print_colored(text, color):
    """Print text with ANSI color"""
    print(f"{color}{text}{Colors.NC}")


def print_separator(char='=', length=42):
    """Print separator line"""
    print(char * length)


def extract_keys_from_file(filepath, language_tag):
    """Extract localization keys from a .yml file"""
    keys = []
    try:
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            for line in f:
                # Skip comments and language headers
                if line.strip().startswith('#') or language_tag in line:
                    continue
                # Check if line contains ':'
                if ':' in line:
                    # Extract key name (before first ':')
                    stripped = line.lstrip()
                    key = stripped.split(':')[0]
                    # Filter keys starting with [A-Za-z_]
                    if key and re.match(r'^[A-Za-z_]', key):
                        keys.append(key)
    except Exception as e:
        print_colored(f"Error reading file {filepath}: {e}", Colors.RED)
    return keys


def find_full_line(filepath, key):
    """Find the complete line for a key in yml file"""
    try:
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            for line in f:
                stripped = line.lstrip()
                if stripped.startswith(f"{key}:"):
                    # Return line without leading whitespace
                    return stripped.rstrip()
    except Exception as e:
        print_colored(f"Error reading file {filepath}: {e}", Colors.RED)
    return None


def check_localization(ui):
    """Check localization completeness - replicates check_*.sh logic"""
    print_separator()
    print(ui['check_header'])
    print_separator()
    print()

    # Check directories exist
    if not os.path.isdir(RUSSIAN_DIR):
        print_colored(ui['error_russian_dir'], Colors.RED)
        print(f"Current working directory: {os.getcwd()}")
        print(f"Looking for: {os.path.abspath(RUSSIAN_DIR)}")
        return 1

    if not os.path.isdir(ENGLISH_DIR):
        print_colored(ui['error_english_dir'], Colors.RED)
        print(f"Current working directory: {os.getcwd()}")
        print(f"Looking for: {os.path.abspath(ENGLISH_DIR)}")
        return 1

    # Create/clear temp directory
    if os.path.exists(TEMP_DIR):
        shutil.rmtree(TEMP_DIR)
    os.makedirs(TEMP_DIR)

    print_colored(ui['step1_merge'], Colors.BLUE)
    print()

    # Files for storing keys
    russian_all_keys_file = os.path.join(TEMP_DIR, 'russian_all_keys.txt')
    english_all_keys_file = os.path.join(TEMP_DIR, 'english_all_keys.txt')
    russian_keys_with_files_file = os.path.join(TEMP_DIR, 'russian_keys_with_files.txt')
    english_keys_with_files_file = os.path.join(TEMP_DIR, 'english_keys_with_files.txt')

    russian_all_keys = []
    russian_keys_with_files = []

    # Process Russian files
    print(ui['processing_russian'])
    russian_files_count = 0
    for filename in sorted(os.listdir(RUSSIAN_DIR)):
        if filename.endswith('.yml'):
            filepath = os.path.join(RUSSIAN_DIR, filename)
            keys = extract_keys_from_file(filepath, 'l_russian:')
            for key in keys:
                russian_all_keys.append(key)
                russian_keys_with_files.append(f"{key}|{filename}")
            russian_files_count += 1

    print_colored(f"  {ui['processed_russian']} {russian_files_count}", Colors.GREEN)
    print()

    english_all_keys = []
    english_keys_with_files = []

    # Process English files
    print(ui['processing_english'])
    english_files_count = 0
    for filename in sorted(os.listdir(ENGLISH_DIR)):
        if filename.endswith('.yml'):
            filepath = os.path.join(ENGLISH_DIR, filename)
            keys = extract_keys_from_file(filepath, 'l_english:')
            for key in keys:
                english_all_keys.append(key)
                english_keys_with_files.append(f"{key}|{filename}")
            english_files_count += 1

    print_colored(f"  {ui['processed_english']} {english_files_count}", Colors.GREEN)
    print()

    # Write to files and deduplicate
    russian_unique = sorted(set(russian_all_keys))
    english_unique = sorted(set(english_all_keys))

    with open(russian_all_keys_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(russian_unique))

    with open(english_all_keys_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(english_unique))

    with open(russian_keys_with_files_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(sorted(russian_keys_with_files)))

    with open(english_keys_with_files_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(sorted(english_keys_with_files)))

    print_colored(ui['step2_compare'], Colors.BLUE)
    print()
    print_colored(f"  {ui['unique_russian']} {len(russian_unique)}", Colors.GREEN)
    print_colored(f"  {ui['unique_english']} {len(english_unique)}", Colors.GREEN)
    print()

    # Find missing keys
    missing_keys = sorted(set(russian_unique) - set(english_unique))
    missing_count = len(missing_keys)

    # Save missing keys to file (always create, even if empty)
    missing_keys_file = os.path.join(TEMP_DIR, 'missing_keys.txt')
    with open(missing_keys_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(missing_keys))

    if missing_count == 0:
        print_colored(f"  {ui['all_keys_present']}", Colors.GREEN)
        print()
        print_separator()
        print(ui['localization_complete'])
        print_separator()
        return 0

    print_colored(f"  {ui['missing_keys_found']} {missing_count}", Colors.RED)
    print()

    # Calculate completion percentage
    percentage = 0
    if len(russian_unique) > 0:
        percentage = ((len(russian_unique) - missing_count) * 100) // len(russian_unique)
        print_colored(f"{ui['completion']} {percentage}%", Colors.YELLOW)
        print()

    print_colored(ui['step3_search'], Colors.BLUE)
    print()

    # Create report
    with open(REPORT_FILE, 'w', encoding='utf-8') as report:
        report.write("Отчет об отсутствующих ключах локализации\n")
        report.write(f"Создан: {datetime.now()}\n")
        report.write(f"{_get_credits_line()}\n")
        report.write("========================================\n")
        report.write("\n")
        report.write("СТАТИСТИКА:\n")
        report.write(f"  Всего русских ключей: {len(russian_unique)}\n")
        report.write(f"  Всего английских ключей: {len(english_unique)}\n")
        report.write(f"  Отсутствующих ключей: {missing_count}\n")
        report.write(f"  Завершенность: {percentage}%\n")
        report.write("\n")
        report.write("========================================\n")
        report.write("\n")

        # Group missing keys by file
        grouped_file = os.path.join(TEMP_DIR, 'grouped_by_files.txt')
        grouped_lines = []

        # Load russian_keys_with_files mapping
        key_to_file = {}
        with open(russian_keys_with_files_file, 'r', encoding='utf-8') as f:
            for line in f:
                if '|' in line:
                    key, filename = line.strip().split('|', 1)
                    key_to_file[key] = filename

        # Create grouped list
        for key in missing_keys:
            if key in key_to_file:
                russian_file = key_to_file[key]
                english_file = russian_file.replace('_l_russian.yml', '_l_english.yml')
                grouped_lines.append(f"{english_file}|{key}")

        grouped_lines.sort()
        with open(grouped_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(grouped_lines))

        # Output results
        report.write("ОТСУТСТВУЮЩИЕ КЛЮЧИ ПО ФАЙЛАМ:\n")
        report.write("\n")

        current_file = ""
        keys_in_file = []
        keys_count = 0

        for line in grouped_lines:
            if '|' not in line:
                continue
            file, key = line.split('|', 1)

            if file != current_file:
                # Output previous file
                if current_file:
                    russian_file = current_file.replace('_l_english.yml', '_l_russian.yml')

                    print_colored(f"{ui['file']} {current_file}", Colors.YELLOW)
                    print_colored(f"  {ui['missing_in_file']} {keys_count}", Colors.RED)
                    print_colored(f"  {ui['path_original']} {RUSSIAN_DIR}/{russian_file}", Colors.BLUE)
                    print_colored(f"  {ui['path_translation']} {ENGLISH_DIR}/{current_file}", Colors.BLUE)
                    print()

                    report.write("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
                    report.write(f"ФАЙЛ: {current_file}\n")
                    report.write(f"Отсутствующих ключей: {keys_count}\n")
                    report.write("\n")
                    report.write("Путь к русскому оригиналу:\n")
                    report.write(f"  {RUSSIAN_DIR}/{russian_file}\n")
                    report.write("\n")
                    report.write("Путь к английскому файлу (добавьте ключи сюда):\n")
                    report.write(f"  {ENGLISH_DIR}/{current_file}\n")
                    report.write("\n")
                    report.write("Отсутствующие ключи:\n")
                    for k in keys_in_file:
                        report.write(f"  - {k}\n")
                    report.write("\n")

                # Start new file
                current_file = file
                keys_in_file = [key]
                keys_count = 1
            else:
                keys_in_file.append(key)
                keys_count += 1

        # Output last file
        if current_file:
            russian_file = current_file.replace('_l_english.yml', '_l_russian.yml')

            print_colored(f"{ui['file']} {current_file}", Colors.YELLOW)
            print_colored(f"  {ui['missing_in_file']} {keys_count}", Colors.RED)
            print_colored(f"  {ui['path_original']} {RUSSIAN_DIR}/{russian_file}", Colors.BLUE)
            print_colored(f"  {ui['path_translation']} {ENGLISH_DIR}/{current_file}", Colors.BLUE)
            print()

            report.write("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
            report.write(f"ФАЙЛ: {current_file}\n")
            report.write(f"Отсутствующих ключей: {keys_count}\n")
            report.write("\n")
            report.write("Путь к русскому оригиналу:\n")
            report.write(f"  {RUSSIAN_DIR}/{russian_file}\n")
            report.write("\n")
            report.write("Путь к английскому файлу (добавьте ключи сюда):\n")
            report.write(f"  {ENGLISH_DIR}/{current_file}\n")
            report.write("\n")
            report.write("Отсутствующие ключи:\n")
            for k in keys_in_file:
                report.write(f"  - {k}\n")
            report.write("\n")

        report.write("========================================\n")
        report.write("\n")
        report.write("ПОЛНЫЙ СПИСОК ОТСУТСТВУЮЩИХ КЛЮЧЕЙ:\n")
        for key in missing_keys:
            report.write(f"  - {key}\n")

    print_separator()
    print(ui['summary'])
    print_separator()
    print_colored(f"{ui['localization_completion']} {Colors.YELLOW}{percentage}%{Colors.NC}")
    print_colored(f"{ui['missing_keys']} {Colors.RED}{missing_count}{Colors.NC}")
    print()
    print_colored(f"{ui['report_saved']} {REPORT_FILE}", Colors.GREEN)
    print_colored(f"{ui['temp_saved']} {TEMP_DIR}/", Colors.GREEN)
    print()

    return 1


def create_wip_files(ui):
    """Create WIP files for translation - replicates create_*.sh logic"""
    print_separator()
    print(ui['create_header'])
    print_separator()
    print()

    # Check temp files exist
    missing_keys_file = os.path.join(TEMP_DIR, 'missing_keys.txt')
    russian_keys_with_files_file = os.path.join(TEMP_DIR, 'russian_keys_with_files.txt')

    if not os.path.exists(missing_keys_file):
        print_colored(ui['error_missing_keys'], Colors.RED)
        print(f"Файл {missing_keys_file} {ui['error_no_temp_file']}")
        return 1

    if not os.path.exists(russian_keys_with_files_file):
        print_colored(f"Ошибка: файл {russian_keys_with_files_file} {ui['error_no_temp_file']}", Colors.RED)
        return 1

    # Create/clear WIP directory
    if os.path.exists(WIP_DIR):
        print(ui['cleaning_wip'])
        shutil.rmtree(WIP_DIR)
    os.makedirs(WIP_DIR)

    print_colored(ui['creating_wip'], Colors.BLUE)
    print()

    # Load russian_keys_with_files mapping
    key_to_file = {}
    with open(russian_keys_with_files_file, 'r', encoding='utf-8') as f:
        for line in f:
            if '|' in line:
                key, filename = line.strip().split('|', 1)
                key_to_file[key] = filename

    total_keys = 0
    files_created = set()

    # Read missing keys
    with open(missing_keys_file, 'r', encoding='utf-8') as f:
        missing_keys = [line.strip() for line in f if line.strip()]

    for missing_key in missing_keys:
        if missing_key not in key_to_file:
            continue

        russian_file = key_to_file[missing_key]
        russian_path = os.path.join(RUSSIAN_DIR, russian_file)

        # Convert to English filename
        english_file = russian_file.replace('_l_russian.yml', '_l_english.yml')
        wip_file = os.path.join(WIP_DIR, english_file)

        # Create file if first key for this file
        if wip_file not in files_created:
            with open(wip_file, 'w', encoding='utf-8') as f:
                f.write(f"# {_get_credits_line()}\n")
                f.write("l_english:\n")
            files_created.add(wip_file)
            print_colored(f"{ui['created']} {english_file}", Colors.GREEN)

        # Find full line in Russian file
        full_line = find_full_line(russian_path, missing_key)

        with open(wip_file, 'a', encoding='utf-8') as f:
            if full_line:
                f.write(f" {full_line}\n")
            else:
                f.write(f' {missing_key}: "[TRANSLATION NEEDED]"\n')

        total_keys += 1

    print()
    print_separator()
    print(ui['summary'])
    print_separator()
    print_colored(f"{ui['files_created']} {len(files_created)}", Colors.GREEN)
    print_colored(f"{ui['total_keys']} {total_keys}", Colors.GREEN)
    print()
    print_colored(f"{ui['files_location']} {WIP_DIR}", Colors.YELLOW)
    print()
    print_colored(ui['instructions'], Colors.BLUE)
    print(ui['instruction1'])
    print(ui['instruction2'])
    print(ui['instruction3'])
    print()

    return 0


def main():
    """Main CLI interface"""
    # Show credits banner
    _show_credits_banner()
    
    # Language selection
    print("Choose language / Выберите язык / Оберіть мову:")
    print("  1. Русский (Russian)")
    print("  2. Українська (Ukrainian)")
    print()

    while True:
        lang_input = input("Enter choice (1/2 or ru/ua): ").strip().lower()
        if lang_input in ['1', 'ru', 'rus', 'russian']:
            ui = UI_RU
            break
        elif lang_input in ['2', 'ua', 'ukr', 'ukrainian']:
            ui = UI_UA
            break
        else:
            print_colored("Invalid choice. Please enter 1, 2, ru, or ua", Colors.RED)

    print()

    # Function selection
    if ui == UI_RU:
        print("Выберите функцию:")
        print("  1. Проверка (Check) - проверить полноту локализации")
        print("  2. Создание (Create) - создать файлы для перевода")
        print("  3. Оба (Both) - сначала проверка, затем создание")
    else:
        print("Оберіть функцію:")
        print("  1. Перевірка (Check) - перевірити повноту локалізації")
        print("  2. Створення (Create) - створити файли для перекладу")
        print("  3. Обидва (Both) - спочатку перевірка, потім створення")
    print()

    while True:
        func_input = input("Enter choice (1/2/3 or check/create/both): ").strip().lower()
        if func_input in ['1', 'check']:
            print()
            result = check_localization(ui)
            print()
            input("Press Enter to exit...")
            sys.exit(result)
        elif func_input in ['2', 'create']:
            print()
            result = create_wip_files(ui)
            print()
            input("Press Enter to exit...")
            sys.exit(result)
        elif func_input in ['3', 'both']:
            print()
            result = check_localization(ui)
            print()
            result2 = create_wip_files(ui)
            print()
            input("Press Enter to exit...")
            sys.exit(result or result2)
        else:
            print_colored("Invalid choice. Please enter 1, 2, 3, check, create, or both", Colors.RED)


if __name__ == '__main__':
    main()
