# THIS scope is INITIATOR COUNTRY
bz_initiate_breakthrough = {
	log = "========================================================"
	log = "[GetDateText]: [Root.GetName]: bz_initiate_breakthrough id = [?global.bz_breakthrough_id]"
	log = "========================================================"

	# Инициализируем глобальные константы
	bz_init_constants = yes

	# Пересчитываем количество активных провинций в погран зонах для каждых регионов
	bz_recalculate_active_bz_provinces_count = yes

	# Цикл по выбранным для прорыва погранзонам
	for_each_scope_loop = {
		array = bz_selected_states

		# Отключаем проверка на создание погранзон в текущей погранзоне
		set_state_flag = bz_disable_creation_flag

		# Передаём БЗ зону её реальному владельцу (убираем непроходимость для врага)
		transfer_state_to = bz_owner

		# Спавним юниты для обработки прорыва данной погран зоны
		bz_state_spawn_units = yes
	}

	clear_array = bz_selected_states

	# Updates manpower for countries that has spawned units for BZ breach
	every_country = {
		limit = { has_war = yes }
		bz_update_new_manpower = yes
	}

	# Переходим на следующий id прорыва границы (используется для выбора массива, хранящего заспавненые юниты)
	add_to_variable = { global.bz_breakthrough_id = 1 }
}

bz_init_state_manpower_pools = {
	meta_effect = {
		text = { add_to_array = { global.bz_manpower_pool_[REGION_INDEX]_bz_states = THIS } }
		REGION_INDEX = "[?bz_manpower_owner_pool_index]"
	}
	meta_effect = {
		text = { add_to_array = { global.bz_manpower_pool_[REGION_INDEX]_bz_states = THIS } }
		REGION_INDEX = "[?bz_manpower_other_pool_index]"
	}
}

bz_recalculate_active_bz_provinces_count = {

	for_loop_effect = { # Pools indexes
		start = 0
		end = global.selected_region_indexes_count
		value = pointer

		meta_effect = {
			text = { 
				set_variable = { global.bz_manpower_pool_[REGION_INDEX]_active_bz_provinces_count = 0 }

				for_each_scope_loop = { # BZ state
					array = global.bz_manpower_pool_[REGION_INDEX]_bz_states

					owner = { # Owner of BZ state
						if = { 
							limit = { has_country_flag = is_bz_country }
							
							add_to_variable = { global.bz_manpower_pool_[REGION_INDEX]_active_bz_provinces_count = PREV.provinces_count }
						}
					}
				}
				
				# Устанавливаем минимальное число пограничников, требуемое для данной погранзоны
				set_variable = { global.bz_manpower_pool_[REGION_INDEX]_min_value = global.bz_manpower_pool_[REGION_INDEX]_active_bz_provinces_count }
				multiply_variable = { global.bz_manpower_pool_[REGION_INDEX]_min_value = global.bz_border_guards_manpower_per_division }
			}
			REGION_INDEX = "[?pointer]"
		}
	}
}

bz_init_constants = {
	set_variable = { global.bz_border_guards_manpower_per_division = 300 }
}

# THIS scope is Country
bz_ensure_border_guards_template = {
	if = {
		limit = { NOT = { has_template = "Border Guards" } }
		division_template = {
			name = "Border Guards"
			is_locked = yes

			regiments = { 
				border_guard = { x = 0 y = 0 }
				border_guard = { x = 0 y = 1 }
				border_guard = { x = 0 y = 2 }
			}
		}
	}
}


# PREV scope is BZ STATE
# THIS scope is BZ ADJACENT STATE
#
# THIS scope must contain temp var "temp_other_country"
bz_spawn_units_in_state_if_its_owner_at_war_with_other_country = {
	if = { # Если владелец смежной области в войне с страной-инициатором
		limit = { owner = { has_war_with = temp_other_country } }

		# Высчитываем, сколько другая сторона может использовать menpower для создания юнита
		set_temp_variable = { temp_bz_manpower_to_spawn = 0 }
		set_temp_variable = { temp_bz_manpower_sum_pool = 0 }
		set_temp_variable = { temp_bz_manpower_owner_pool = 0 }
		set_temp_variable = { temp_bz_manpower_other_pool = 0 }

		meta_effect = { # Высчитываем, какая часть manpower из региональных manpower_pool будет использована при прорыве погранзоны
			text = {
				owner = {
					add_to_temp_variable = { temp_bz_manpower_owner_pool = bz_manpower_pool_[OWNER_REGION_INDEX] }
					add_to_temp_variable = { temp_bz_manpower_other_pool = bz_manpower_pool_[OTHER_REGION_INDEX] }
				}

				multiply_temp_variable = { temp_bz_manpower_owner_pool = PREV.provinces_count }					
				multiply_temp_variable = { temp_bz_manpower_other_pool = PREV.provinces_count }	

				divide_temp_variable = { temp_bz_manpower_owner_pool = global.bz_manpower_pool_[OWNER_REGION_INDEX]_active_bz_provinces_count }
				divide_temp_variable = { temp_bz_manpower_other_pool = global.bz_manpower_pool_[OTHER_REGION_INDEX]_active_bz_provinces_count }
			}

			OWNER_REGION_INDEX = "[?PREV.bz_manpower_owner_pool_index]"
			OTHER_REGION_INDEX = "[?PREV.bz_manpower_other_pool_index]"
		}

		# Высчитываем итоговое количество manpower, которое будет использовано при прорыве погранзоны
		add_to_temp_variable = { temp_bz_manpower_sum_pool = temp_bz_manpower_owner_pool }
		add_to_temp_variable = { temp_bz_manpower_sum_pool = temp_bz_manpower_other_pool }
		add_to_temp_variable = { temp_bz_manpower_to_spawn = temp_bz_manpower_sum_pool }
		
		# Подготавливаем данные для цикла по смежным с погранзоной провинциям в данном смежном стейте
		set_temp_variable = { temp_start_index = PREV.bz_adjacent_states_provinces_start_indexes^temp_bz_adjacent_state_index }
		set_temp_variable = { temp_end_index = PREV.bz_adjacent_states_provinces_end_indexes^temp_bz_adjacent_state_index }
		set_temp_variable = { temp_province_index = temp_start_index }
		set_temp_variable = { temp_provinces_indexes_count = temp_end_index }
		subtract_from_temp_variable = { temp_provinces_indexes_count = temp_start_index }

		# Установка параметров для создания юнита
		set_temp_variable = { temp_delta_manpower = 0 }
		set_temp_variable = { temp_owner = owner }

		# Получаем следующий не занятый id для юнита пограничников
		# (Используется для последующего удаления конкретных юнитов)
		set_temp_variable = { temp_unit_id = 0 }
		owner = { add_to_temp_variable = { temp_unit_id = bz_next_unit_id } }

		if = { # Защита от дурака (смежных областей с 0 провинциями)
			limit = { NOT = { check_variable = { temp_start_index = temp_end_index }}}

			while_loop_effect = {
				limit = { check_variable = { temp_bz_manpower_to_spawn > global.bz_border_guards_manpower_per_division } }
				
				# Получаем id провинции для спавна юнита
				set_temp_variable = { temp_province_id = PREV.bz_adjacent_states_provinces_ids^temp_province_index }

				# Спавним юнит в провинции
				bz_create_border_guards_unit_in_province = yes

				# Регистрируем юнит в системе отслеживания времени существования пограничников
				owner = { add_to_array = { bz_active_units_ids = temp_unit_id } }
				add_to_temp_variable = { temp_unit_id = 1 }

				# Обновляем менпавер, доступный для защиты данного участка границы
				subtract_from_temp_variable = { temp_bz_manpower_to_spawn = global.bz_border_guards_manpower_per_division }

				subtract_from_temp_variable = { temp_delta_manpower = global.bz_border_guards_manpower_per_division }

				#Переходим к следующей провинции, где можно спавнить юниты
				add_to_temp_variable = { temp_province_index = 1 }

				if = { # Если прошли последнюю смежную провинцию в списке, возвращаемся к первой в списке
					limit = { check_variable = { temp_province_index > temp_end_index }}
					
					subtract_from_temp_variable = { temp_province_index = temp_provinces_indexes_count }
				}					
			}

			# Высчитываем разделённый delta_manpower
			set_temp_variable = { temp_delta_manpower_owner_pool = temp_delta_manpower }
			set_temp_variable = { temp_delta_manpower_other_pool = temp_delta_manpower }
			multiply_temp_variable = { temp_delta_manpower_owner_pool = temp_bz_manpower_owner_pool }
			multiply_temp_variable = { temp_delta_manpower_other_pool = temp_bz_manpower_other_pool }
			divide_temp_variable = { temp_delta_manpower_owner_pool = temp_bz_manpower_sum_pool }
			divide_temp_variable = { temp_delta_manpower_other_pool = temp_bz_manpower_sum_pool }

			# Обновляем менпавер, выделенный на защиту данного региона
			meta_effect = {
				text = { 
					owner = { 
						add_to_variable = { bz_delta_manpower_pool_[OWNER_REGION_INDEX] = temp_delta_manpower_owner_pool }
						add_to_variable = { bz_delta_manpower_pool_[OTHER_REGION_INDEX] = temp_delta_manpower_other_pool }
					}
				}

				OWNER_REGION_INDEX = "[?PREV.bz_manpower_owner_pool_index]"
				OTHER_REGION_INDEX = "[?PREV.bz_manpower_other_pool_index]"
			}
		}

		# Обновляем следующий не занятый id для юнита пограничников
		owner = { set_variable = { bz_next_unit_id = temp_unit_id } }
	}
}

# Spawn units in specific target BZ state
#
# PREV scope is COUNTRY
# THIS scope is BZ STATE
bz_state_spawn_units = {
	set_temp_variable = { temp_initiator_country = PREV }

	if = { # Если владельцем прорываемой ПЗ является ТЕКУЩАЯ страна 
		limit = { check_variable = { bz_owner = temp_initiator_country } }

		# Спавним юниты для владельца погранзоны
		bz_spawn_units_for_bz_state_owner = yes

		set_temp_variable = { temp_other_country = temp_initiator_country }
		set_temp_variable = { temp_bz_adjacent_state_index = 0 }
		for_each_scope_loop = { # THIS scope is bz ADJACENT STATE
			array = bz_adjacent_states_ids

			# Спавним юниты для защищающейся страны в провинциях области, смежной с погранзоной
			bz_spawn_units_in_state_if_its_owner_at_war_with_other_country = yes

			# Переходим к следующему смежному стейту
			add_to_temp_variable = { temp_bz_adjacent_state_index = 1 }
		}

	} 
	else_if = { # Иначе если владельцем погранзоны является ДРУГАЯ страна, с которой не идёт война
		limit = { 
			owner = { has_war_with = temp_initiator_country }
			# bz_owner = { has_war_with = temp_initiator_country } # TODO : bz_onwer var cannot be used as a scope
		}

		# Спавним юниты для владельца погранзоны
		bz_spawn_units_for_bz_state_owner = yes

		set_temp_variable = { temp_other_country = owner }
		set_temp_variable = { temp_bz_adjacent_state_index = 0 }

		for_each_scope_loop = { # THIS scope is bz ADJACENT STATE
			array = bz_adjacent_states_ids
			
			log = "  A3 index [?temp_bz_adjacent_state_index]"
			log = "  A3 this = [?THIS] [?THIS.GetID] [THIS.GetName]"
			# Спавним юниты для защищающейся страны в провинциях области, смежной с погранзоной
			bz_spawn_units_in_state_if_its_owner_at_war_with_other_country = yes

			# Переходим к следующему смежному стейту
			add_to_temp_variable = { temp_bz_adjacent_state_index = 1 }
		}
	}
	else = {
		log = " Unknown branch"
	}
}

#THIS scope is BZ STATE
bz_spawn_units_for_bz_state_owner = {
	# Считаем, сколько менпавера может выделить на защиту прорываемой ПЗ её владелец
	set_temp_variable = { temp_bz_manpower_to_spawn = THIS.provinces_count }

	meta_effect = {
		text = {
			owner = { multiply_temp_variable = { temp_bz_manpower_to_spawn = bz_manpower_pool_[REGION_INDEX] } }
			divide_temp_variable = { temp_bz_manpower_to_spawn = global.bz_manpower_pool_[REGION_INDEX]_active_bz_provinces_count }
		}
		REGION_INDEX = "[?THIS.bz_manpower_owner_pool_index]"
	}
	round_temp_variable = temp_bz_manpower_to_spawn
	set_temp_variable = { temp_bz_manpower_to_spawn_start = temp_bz_manpower_to_spawn }

	# Спавним юниты в ПЗ
	set_temp_variable = { temp_owner = owner }
	set_temp_variable = { temp_unit_id = 0 }
	owner = { add_to_temp_variable = { temp_unit_id = bz_next_unit_id } }
	while_loop_effect = {
		limit = { check_variable = { temp_bz_manpower_to_spawn > global.bz_border_guards_manpower_per_division } }

		bz_create_border_guards_unit_in_state = yes

		# Регистрируем юнит в системе отслеживания времени существования пограничников
		owner = { add_to_array = { bz_active_units_ids = temp_unit_id } }
		add_to_temp_variable = { temp_unit_id = 1 }

		subtract_from_temp_variable = { temp_bz_manpower_to_spawn = global.bz_border_guards_manpower_per_division }
	}

	owner = { set_variable = { bz_next_unit_id = temp_unit_id } }

	# Вычитаем менпавер из пула
	subtract_from_temp_variable = { temp_bz_manpower_to_spawn = temp_bz_manpower_to_spawn_start }

	meta_effect = {
		text = { 
			owner = { add_to_variable = { bz_delta_manpower_pool_[REGION_INDEX] = temp_bz_manpower_to_spawn } }
		}
		REGION_INDEX = "[?THIS.bz_manpower_owner_pool_index]"
	}
}

# Create UNIT in specific STATE
#
# THIS scope is STATE
# THIS scope must contain temp_variables:
# 1. "temp_owner"
# 2. "temp_unit_id"
bz_create_border_guards_unit_in_state = {
	meta_effect = {
		text = {
			[OWNER] = { bz_ensure_border_guards_template = yes }

			create_unit = {
				division = "name = \"Border Guards\" division_template = \"Border Guards\" start_experience_factor = 0.5"
				owner = [OWNER]
				id = [UNIT_ID]
				allow_spawning_on_enemy_provs = yes
			}
			
			[OWNER] = { 
				# Добавляем id юнита в текущий прорыв 
				add_to_array = { breakthrough_[BREAKTHROUGH_ID]_units_ids = [UNIT_ID] } 
				
				# Добавляем id прорыва в регистр страны
				if = {
					limit = { NOT = { is_in_array = { bz_breakthrough_ids_with_active_units = global.bz_breakthrough_id } } }
					add_to_array = { bz_breakthrough_ids_with_active_units = global.bz_breakthrough_id }
				}
			}
		}
		OWNER = "[?temp_owner.GetTag]"
		UNIT_ID = "[?temp_unit_id]"
		BREAKTHROUGH_ID = "[?global.bz_breakthrough_id]"
	}
}

# Creates UNIT in specific PROVINCE
#
# THIS scope must be STATE
# THIS scope must contain temp_variables:
# 1. "temp_owner"
# 2. "temp_province_id"
# 3. "temp_unit_id"
bz_create_border_guards_unit_in_province = {	
	meta_effect = {
		text = {
			[OWNER] = { bz_ensure_border_guards_template = yes }
			# Создаём юнит пограничников
			create_unit = {
				division = "name = \"Border Guards\" division_template = \"Border Guards\" start_experience_factor = 0.5"
				owner = [OWNER]
				prioritize_location = [PROVINCE_ID]
				id = [UNIT_ID]
				allow_spawning_on_enemy_provs = yes
			}

			[OWNER] = { 
				# Добавляем id юнита в текущий прорыв 
				add_to_array = { breakthrough_[BREAKTHROUGH_ID]_units_ids = [UNIT_ID] } 
				
				# Добавляем id прорыва в регистр страны
				if = {
					limit = { NOT = { is_in_array = { bz_breakthrough_ids_with_active_units = global.bz_breakthrough_id } } }
					add_to_array = { bz_breakthrough_ids_with_active_units = global.bz_breakthrough_id }
				}
			}
		}
		OWNER = "[?temp_owner.GetTag]"
		PROVINCE_ID = "[?temp_province_id]"
		UNIT_ID = "[?temp_unit_id]"
		BREAKTHROUGH_ID = "[?global.bz_breakthrough_id]"
	}
}


bz_clamp_manpower = {
	if = {
		limit = { check_variable = { bz_manpower > 0 }}
		clamp_variable = { var = bz_manpower max = manpower }
	}
	else_if = {
		limit = { check_variable = { bz_manpower < 0 } }

		meta_effect = {
			text = {
				set_temp_variable = { temp_used_manpower = bz_manpower_pool_[REGION_INDEX] }
				multiply_temp_variable = { temp_used_manpower = -1 }
				if = {
					limit = { check_variable = { bz_manpower < temp_used_manpower } }
					set_variable = { bz_manpower = temp_used_manpower }
				}
			}
			REGION_INDEX = "[?selected_region]"
		}
	}
}

# Sets the manpower to specific region of REGIONS MAP
bz_confirm_manpower = {
	bz_clamp_manpower = yes

	
	set_temp_variable = { temp_bz_manpower = bz_manpower }
	multiply_temp_variable = { temp_bz_manpower = -1 }
	add_manpower = temp_bz_manpower

	add_to_variable = { BZ_region_manpower = bz_manpower }

	meta_effect = {
		text = { add_to_variable = { bz_manpower_pool_[REGION_INDEX] = bz_manpower } }
		REGION_INDEX = "[?selected_region]"
	}
	set_variable = { bz_manpower = 0 } 
}

# THIS scope is Country
# Updates manpower in bz_manpower_pools after units creation
bz_update_new_manpower = {
	for_loop_effect = {
		end = global.selected_region_indexes_count
		value = p

		if = {
			limit = { 
				meta_trigger = {
					text = { has_variable = bz_delta_manpower_pool_[REGION_INDEX] }
					REGION_INDEX = "[?p]"
				}
			}

			meta_effect = {
				text = { 
					add_to_variable = { bz_manpower_pool_[REGION_INDEX] = bz_delta_manpower_pool_[REGION_INDEX] }
					clear_variable = bz_delta_manpower_pool_[REGION_INDEX]
				}
				REGION_INDEX = "[?p]"
			}
		}
	}

	# Обновляем значения в гуи регионов
	map_update_region_manpower = yes 
}

#THIS scope is Country
bz_recalculate_array_of_states_can_breakthrough = {
	clear_array = bz_states_can_breakthrough
	set_temp_variable = { initiator_country = THIS }

	for_each_scope_loop = { # THIS scope is bz STATE
		array = global.bz_states_ids

		if = { # Если владельцем прорываемой ПЗ является ТЕКУЩАЯ страна 
			limit = { owner = { original_tag = RUS } }

			for_each_scope_loop = { # THIS scope is bz ADJACENT STATE
				array = bz_adjacent_states_ids
				break = break_flag

				if = { # Если владелец смежной области в войне с страной-инициатором
					limit = { owner = { has_war_with = initiator_country } }

					# Добавляем id стейта погранзоны в массив доступных прорывов в стране
					add_to_array = { PREV.PREV.bz_states_can_breakthrough = THIS }
					set_temp_variable = { break_flag = 1 }
				}
			}

		} 
		else_if = { 
			limit = {
				NOT = { owner = { has_war_with = initiator_country } }
				#PREV = { has_war_with = bz_owner }
			}

			add_to_array = { PREV.bz_states_can_breakthrough = THIS }
		}
	}
}

bz_tick_states_status = {
	
}

# PREV scope is BZ state
# THIS scope is TARGET COUNTRY
bz_transfer_state_to = {
	transfer_state_to = THIS
	add_to_variable = { global.bz_transfered_states_count = 1 }
}